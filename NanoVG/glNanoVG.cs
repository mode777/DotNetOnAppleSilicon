
//
// Copyright (c) 2009-2013 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//

/*
 * Por to C#
 * Copyright (c) 2016 Miguel A. Guirado L. https://sites.google.com/site/bitiopia/
 * 
 * 	NanoVG.net is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  any later version.
 *
 *  NanoVG.net is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with NanoVG.net.  If not, see <http://www.gnu.org/licenses/>. See
 *  the file lgpl-3.0.txt for more details.
 */

//#define NANOVG_GLES2_IMPLEMENTATION
////#define NANOVG_GL_USE_STATE_FILTER

//#if NANOVG_GL2_IMPLEMENTATION
//#define NANOVG_GL2
//#define NANOVG_GL_IMPLEMENTATION
//#elif NANOVG_GL3_IMPLEMENTATION
//#define NANOVG_GL3
//#define NANOVG_GL_IMPLEMENTATION
//#define NANOVG_GL_USE_UNIFORMBUFFER
//#endif

using System;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;
using GLES2;

namespace NanoVGDotNet
{
	public static class GlNanoVG
	{
		const int GL_TRUE = 1;
		const int GL_FALSE = 0;

		public const int ICON_LOGIN = 0xE740;
		public const int ICON_TRASH = 0xE729;
		public const int ICON_SEARCH = 0x1F50D;
		public const int ICON_CIRCLED_CROSS = 0x2716;
		public const int ICON_CHEVRON_RIGHT = 0xE75E;
		public const int ICON_CHECK = 0x2713;

		static GLNVGcontext gl;

		#region SHADERS

		static string shaderHeader =
			"#version 100\n" +
			"#define NANOVG_GL2 1\n" +
			"#define UNIFORMARRAY_SIZE 11\n" +
			"\n";

		static string fillVertShader =
			"#ifdef NANOVG_GL3\n" +
			"	uniform vec2 viewSize;\n" +
			"	in vec2 vertex;\n" +
			"	in vec2 tcoord;\n" +
			"	out vec2 ftcoord;\n" +
			"	out vec2 fpos;\n" +
			"#else\n" +
			"	uniform vec2 viewSize;\n" +
			"	attribute vec2 vertex;\n" +
			"	attribute vec2 tcoord;\n" +
			"	varying vec2 ftcoord;\n" +
			"	varying vec2 fpos;\n" +
			"#endif\n" +
			"void main(void) {\n" +
			"	ftcoord = tcoord;\n" +
			"	fpos = vertex;\n" +
			"	gl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 1.0 - 2.0*vertex.y/viewSize.y, 0, 1);\n" +
			"}\n";

		static string fillFragShader =
			"#ifdef GL_ES\n" +
			"#if defined(GL_FRAGMENT_PRECISION_HIGH) || defined(NANOVG_GL3)\n" +
			" precision highp float;\n" +
			"#else\n" +
			" precision mediump float;\n" +
			"#endif\n" +
			"#endif\n" +
			"#ifdef NANOVG_GL3\n" +
			"#ifdef USE_UNIFORMBUFFER\n" +
			"	layout(std140) uniform frag {\n" +
			"		mat3 scissorMat;\n" +
			"		mat3 paintMat;\n" +
			"		vec4 innerCol;\n" +
			"		vec4 outerCol;\n" +
			"		vec2 scissorExt;\n" +
			"		vec2 scissorScale;\n" +
			"		vec2 extent;\n" +
			"		float radius;\n" +
			"		float feather;\n" +
			"		float strokeMult;\n" +
			"		float strokeThr;\n" +
			"		int texType;\n" +
			"		int type;\n" +
			"	};\n" +
			"#else\n" + // NANOVG_GL3 && !USE_UNIFORMBUFFER
			"	uniform vec4 frag[UNIFORMARRAY_SIZE];\n" +
			"#endif\n" +
			"	uniform sampler2D tex;\n" +
			"	in vec2 ftcoord;\n" +
			"	in vec2 fpos;\n" +
			"	out vec4 outColor;\n" +
			"#else\n" + // !NANOVG_GL3
			"	uniform vec4 frag[UNIFORMARRAY_SIZE];\n" +
			"	uniform sampler2D tex;\n" +
			"	varying vec2 ftcoord;\n" +
			"	varying vec2 fpos;\n" +
			"#endif\n" +
			"#ifndef USE_UNIFORMBUFFER\n" +
			"	#define scissorMat mat3(frag[0].xyz, frag[1].xyz, frag[2].xyz)\n" +
			"	#define paintMat mat3(frag[3].xyz, frag[4].xyz, frag[5].xyz)\n" +
			"	#define innerCol frag[6]\n" +
			"	#define outerCol frag[7]\n" +
			"	#define scissorExt frag[8].xy\n" +
			"	#define scissorScale frag[8].zw\n" +
			"	#define extent frag[9].xy\n" +
			"	#define radius frag[9].z\n" +
			"	#define feather frag[9].w\n" +
			"	#define strokeMult frag[10].x\n" +
			"	#define strokeThr frag[10].y\n" +
			"	#define texType int(frag[10].z)\n" +
			"	#define type int(frag[10].w)\n" +
			"#endif\n" +
			"\n" +
			"float sdroundrect(vec2 pt, vec2 ext, float rad) {\n" +
			"	vec2 ext2 = ext - vec2(rad,rad);\n" +
			"	vec2 d = abs(pt) - ext2;\n" +
			"	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;\n" +
			"}\n" +
			"\n" +
			"// Scissoring\n" +
			"float scissorMask(vec2 p) {\n" +
			"	vec2 sc = (abs((scissorMat * vec3(p,1.0)).xy) - scissorExt);\n" +
			"	sc = vec2(0.5,0.5) - sc * scissorScale;\n" +
			"	return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);\n" +
			"}\n" +
			"#ifdef EDGE_AA\n" +
			"// Stroke - from [0..1] to clipped pyramid, where the slope is 1px.\n" +
			"float strokeMask() {\n" +
			"	return min(1.0, (1.0-abs(ftcoord.x*2.0-1.0))*strokeMult) * min(1.0, ftcoord.y);\n" +
			"}\n" +
			"#endif\n" +
			"\n" +
			"void main(void) {\n" +
			"   vec4 result;\n" +
			"	float scissor = scissorMask(fpos);\n" +
			"#ifdef EDGE_AA\n" +
			"	float strokeAlpha = strokeMask();\n" +
			"#else\n" +
			"	float strokeAlpha = 1.0;\n" +
			"#endif\n" +
			"	if (type == 0) {			// Gradient\n" +
			"		// Calculate gradient color using box gradient\n" +
			"		vec2 pt = (paintMat * vec3(fpos,1.0)).xy;\n" +
			"		float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);\n" +
			"		vec4 color = mix(innerCol,outerCol,d);\n" +
			"		// Combine alpha\n" +
			"		color *= strokeAlpha * scissor;\n" +
			"		result = color;\n" +
			"	} else if (type == 1) {		// Image\n" +
			"		// Calculate color fron texture\n" +
			"		vec2 pt = (paintMat * vec3(fpos,1.0)).xy / extent;\n" +
			"#ifdef NANOVG_GL3\n" +
			"		vec4 color = texture(tex, pt);\n" +
			"#else\n" +
			"		vec4 color = texture2D(tex, pt);\n" +
			"#endif\n" +
			"		if (texType == 1) color = vec4(color.xyz*color.w,color.w);" +
			"		if (texType == 2) color = vec4(color.x);" +
			"		// Apply color tint and alpha.\n" +
			"		color *= innerCol;\n" +
			"		// Combine alpha\n" +
			"		color *= strokeAlpha * scissor;\n" +
			"		result = color;\n" +
			"	} else if (type == 2) {		// Stencil fill\n" +
			"		result = vec4(1,1,1,1);\n" +
			"	} else if (type == 3) {		// Textured tris\n" +
			"#ifdef NANOVG_GL3\n" +
			"		vec4 color = texture(tex, ftcoord);\n" +
			"#else\n" +
			"		vec4 color = texture2D(tex, ftcoord);\n" +
			"#endif\n" +
			"		if (texType == 1) color = vec4(color.xyz*color.w,color.w);" +
			"		if (texType == 2) color = vec4(color.x);" +
			"		color *= scissor;\n" +
			"		result = color * innerCol;\n" +
			"	}\n" +
			"#ifdef EDGE_AA\n" +
			"	if (strokeAlpha < strokeThr) discard;\n" +
			"#endif\n" +
			"#ifdef NANOVG_GL3\n" +
			"	outColor = result;\n" +
			"#else\n" +
			"	gl_FragColor = result;\n" +
			"#endif\n" +
			"}\n";

		#endregion SHADERS

		static void glnvg__checkError(GLNVGcontext gl, string str)
		{
			uint err;
			if ((gl.flags & (int)NVGcreateFlags.NVG_DEBUG) == 0)
				return;
			err = GL.GetError();
			if (err != GL.NO_ERROR)
			{
				Console.WriteLine(String.Format("Error {0} after {1}\n", err, str));
				return;
			}
		}

		static void glnvg__bindTexture(GLNVGcontext gl, uint tex)
		{
			GL.BindTexture(GL.TEXTURE_2D, tex);
		}

		static int glnvg__maxi(int a, int b)
		{
			return a > b ? a : b;
		}

		static void glnvg__dumpShaderError(uint shader, string name, string type)
		{
			var sb = new StringBuilder(1024);
			uint length;
			GL.GetShaderInfoLog(shader, (uint)sb.Capacity, out length, sb);
			// "Shader %s/%s error:\n%s\n", name, type, str
			Console.WriteLine(String.Format("Shader {0}/{1} error:\n{2}\n", name, type, sb.ToString()));
		}

		static void glnvg__dumpProgramError(uint prog, string name)
		{
			var sb = new StringBuilder(1024);
			uint length;
			GL.GetProgramInfoLog(prog, (uint)sb.Capacity, out length, sb);
			// printf("Program %s error:\n%s\n", name, str);
			Console.WriteLine(String.Format("Shader {0} error:\n{1}\n", name, sb.ToString()));
		}

		static int glnvg__createShader(out GLNVGshader shader, string name, string header, string opts, string vshader, string fshader)
		{
			int status;
			uint prog, vert, frag;
			string[] str = new string[3];
			str[0] = header;
			str[1] = opts != null ? opts : "";

			shader = new GLNVGshader();

			prog = (uint)GL.CreateProgram();
			vert = (uint)GL.CreateShader(GL.VERTEX_SHADER);
			frag = (uint)GL.CreateShader(GL.FRAGMENT_SHADER);
			str[2] = vshader;

			string[] strings = { str[0] + str[1] + vshader };
			int[] lengths = { strings[0].Length };

			unsafe { fixed (int* p = lengths) { GL.ShaderSource(vert, 1, strings, p); } }
			str[2] = fshader;
			strings[0] = str[0] + str[1] + fshader;
			lengths[0] = strings[0].Length;
			unsafe { fixed (int* p = lengths) { GL.ShaderSource(frag, 1, strings, p); } }

			GL.CompileShader(vert);
			GL.GetShaderiv(vert, GL.COMPILE_STATUS, out status);
			if (status != (int)GL_TRUE)
			{
				glnvg__dumpShaderError(vert, name, "vert");
				return 0;
			}

			GL.CompileShader(frag);
			GL.GetShaderiv(frag, GL.COMPILE_STATUS, out status);
			if (status != (int)GL_TRUE)
			{
				glnvg__dumpShaderError(frag, name, "frag");
				return 0;
			}

			GL.AttachShader(prog, vert);
			GL.AttachShader(prog, frag);

			GL.BindAttribLocation(prog, 0, "vertex");
			GL.BindAttribLocation(prog, 1, "tcoord");

			GL.LinkProgram(prog);
			GL.GetProgramiv(prog, GL.LINK_STATUS, out status);
			if (status != (int)GL_TRUE)
			{
				glnvg__dumpProgramError(prog, name);
				return 0;
			}

			shader.prog = prog;
			shader.vert = vert;
			shader.frag = frag;

			return 1;
		}

		static GLNVGcall glnvg__allocCall(GLNVGcontext gl)
		{
			GLNVGcall ret = null;

			if (gl.ncalls + 1 > gl.ccalls)
			{
				int ccalls = glnvg__maxi(gl.ncalls + 1, 128) + gl.ccalls / 2; // 1.5x Overallocate
				//calls = (GLNVGcall*)realloc(gl->calls, sizeof(GLNVGcall) * ccalls);
				Array.Resize<GLNVGcall>(ref gl.calls, ccalls);

				for (int cont = gl.ncalls; cont < ccalls; cont++)
					gl.calls[cont] = new GLNVGcall();

				gl.ccalls = ccalls;
			}

			ret = gl.calls[gl.ncalls++];
			//memset(ret, 0, sizeof(GLNVGcall));
			return ret;
		}

		static int glnvg__deleteTexture(GLNVGcontext gl, int id)
		{
			int i;
			for (i = 0; i < gl.ntextures; i++)
			{
				if (gl.textures[i].id == id)
				{
					if (gl.textures[i].tex != 0 && (gl.textures[i].flags & (int)NVGimageFlagsGL.NVG_IMAGE_NODELETE) == 0)
						unsafe { fixed (uint* p = &gl.textures[i].tex) { GL.DeleteTextures(1, p); } }
					//memset(&gl.textures[i], 0, sizeof(gl.textures[i]));
					gl.textures[i] = new GLNVGtexture();
					return 1;
				}
			}
			return 0;
		}

		static void glnvg__allocTexture(GLNVGcontext gl, out GLNVGtexture tex)
		{
			int i;
			tex = null;

			for (i = 0; i < gl.ntextures; i++)
			{
				if (gl.textures[i].id == 0)
				{
					tex = gl.textures[i];
					break;
				}
			}
			if (tex == null)
			{
				if (gl.ntextures + 1 > gl.ctextures)
				{
					//GLNVGtexture[] textures;
					int ctextures = glnvg__maxi(gl.ntextures + 1, 4) + gl.ctextures / 2; // 1.5x Overallocate
					Array.Resize<GLNVGtexture>(ref gl.textures, ctextures);
					//textures = new GLNVGtexture[ctextures];
					for (int cont = gl.ntextures; cont < ctextures; cont++)
						gl.textures[cont] = new GLNVGtexture();
					//gl.textures = textures;
					gl.ctextures = ctextures;
				}
				tex = gl.textures[gl.ntextures++];
			}
			else
				tex = new GLNVGtexture();

			tex.id = ++gl.textureId;
		}

		static void glnvg__getUniforms(GLNVGshader shader)
		{
			shader.loc[(int)GLNVGuniformLoc.GLNVG_LOC_VIEWSIZE] = GL.GetUniformLocation(shader.prog, "viewSize");
			shader.loc[(int)GLNVGuniformLoc.GLNVG_LOC_TEX] = GL.GetUniformLocation(shader.prog, "tex");

			shader.loc[(int)GLNVGuniformLoc.GLNVG_LOC_FRAG] = GL.GetUniformLocation(shader.prog, "frag");
		}

		static int glnvg__renderCreate(object uptr)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			int align = 4;

			glnvg__checkError(gl, "init");

			if ((gl.flags & (int)NVGcreateFlags.NVG_ANTIALIAS) != 0)
			{
				if (glnvg__createShader(out gl.shader, "shader", shaderHeader, "#define EDGE_AA 1\n", fillVertShader, fillFragShader) == 0)
					return 0;
			}
			else
			{
				if (glnvg__createShader(out gl.shader, "shader", shaderHeader, null, fillVertShader, fillFragShader) == 0)
					return 0;
			}

			glnvg__checkError(gl, "uniform locations");
			glnvg__getUniforms(gl.shader);

			// Create dynamic vertex array
			uint[] buffer = new uint[1];
			unsafe { fixed (uint* p = buffer) { GL.GenBuffers(1, p); } }
			gl.vertBuf = buffer[0];

			int size = (int)GLNVGfragUniforms.GetSize; 
			gl.fragSize = size + align - size % align;

			glnvg__checkError(gl, "create done");

			GL.Finish();

			return 1;
		}

		static void glnvg__deleteShader(GLNVGshader shader)
		{
			if (shader.prog != 0)
				GL.DeleteProgram(shader.prog);
			if (shader.vert != 0)
				GL.DeleteShader(shader.vert);
			if (shader.frag != 0)
				GL.DeleteShader(shader.frag);
		}

		static void glnvg__renderCancel(object uptr)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			gl.nverts = 0;
			gl.npaths = 0;
			gl.ncalls = 0;
			gl.nuniforms = 0;
		}

		public static void glnvg__renderDelete(object uptr)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			int i;
			if (gl == null)
				return;

			glnvg__deleteShader(gl.shader);

			if (gl.vertBuf != 0)
				unsafe { fixed (uint* p = &gl.vertBuf) { GL.DeleteBuffers(1, p); } }

			for (i = 0; i < gl.ntextures; i++)
			{
				if (gl.textures[i].tex != 0 && (gl.textures[i].flags & (int)NVGimageFlagsGL.NVG_IMAGE_NODELETE) == 0)
					unsafe { fixed (uint* p = &gl.textures[i].tex) { GL.DeleteTextures(1, p); } }
			}
			gl = null;
		}

		static int glnvg__renderDeleteTexture(object uptr, int image)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			return glnvg__deleteTexture(gl, image);
		}

		static int glnvg__renderCreateTexture2(object uptr, int type, int w, int h, int imageFlags, Bitmap bmp)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			GLNVGtexture tex;
			glnvg__allocTexture(gl, out tex);

			unsafe { fixed (uint* p = &tex.tex) { GL.GenTextures(1, p); } }
			tex.width = w;
			tex.height = h;
			tex.type = type;
			tex.flags = imageFlags;
			glnvg__bindTexture(gl, tex.tex);

			GL.PixelStorei(GL.UNPACK_ALIGNMENT, 1);

			BitmapData data = bmp.LockBits(new System.Drawing.Rectangle(0, 0, bmp.Width, bmp.Height),
				                  ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
		
			// TODO: Fix
			if (type == (int)NVGtexture.NVG_TEXTURE_RGBA)
				unsafe { GL.TexImage2D(GL.TEXTURE_2D, 0, (int)GL.RGBA, (uint)w, (uint)h, 0,
					GL.RGBA, GL.UNSIGNED_BYTE, data.Scan0.ToPointer()); }
			else
				//glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, w, h, 0, GL_RED, GL_UNSIGNED_BYTE, data);
				unsafe { GL.TexImage2D(GL.TEXTURE_2D, 0, (int)GL.ALPHA, (uint)w, (uint)h, 0,
					GL.LUMINANCE, GL.UNSIGNED_BYTE, data.Scan0.ToPointer()); }

			bmp.UnlockBits(data);

			if ((imageFlags & (int)NVGimageFlags.NVG_IMAGE_GENERATE_MIPMAPS) != 0)
			{
				GL.TexParameteri(GL.TEXTURE_2D,
					GL.TEXTURE_MIN_FILTER, (int)GL.LINEAR_MIPMAP_LINEAR);
			}
			else
			{
				GL.TexParameteri(GL.TEXTURE_2D,
					GL.TEXTURE_MIN_FILTER, (int)GL.LINEAR);
			}
			GL.TexParameteri(GL.TEXTURE_2D,
				GL.TEXTURE_MAG_FILTER, (int)GL.LINEAR);

			if ((imageFlags & (int)NVGimageFlags.NVG_IMAGE_REPEATX) != 0)
				GL.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, (int)GL.REPEAT);
			else
				GL.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, (int)GL.CLAMP_TO_EDGE);

			if ((imageFlags & (int)NVGimageFlags.NVG_IMAGE_REPEATY) != 0)
				GL.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, (int)GL.REPEAT);
			else
				GL.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, (int)GL.CLAMP_TO_EDGE);

			GL.PixelStorei(GL.UNPACK_ALIGNMENT, 4);

			glnvg__checkError(gl, "create tex");
			glnvg__bindTexture(gl, 0);

			return tex.id;
		}

		static int glnvg__renderCreateTexture(object uptr, int type, int w, int h, int imageFlags, byte[] data)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			GLNVGtexture tex;
			glnvg__allocTexture(gl, out tex);

			unsafe { fixed (uint* p = &tex.tex) { GL.GenTextures(1, p); } }
			tex.width = w;
			tex.height = h;
			tex.type = type;
			tex.flags = imageFlags;
			glnvg__bindTexture(gl, tex.tex);

			GL.PixelStorei(GL.UNPACK_ALIGNMENT, 1);

			if (type == (int)NVGtexture.NVG_TEXTURE_RGBA)
				unsafe { fixed(void* p = data) { GL.TexImage2D(GL.TEXTURE_2D, 0, (int)GL.RGBA, (uint)w, (uint)h, 0,
					GL.RGBA, GL.UNSIGNED_BYTE, p); } }
			else
                //glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, w, h, 0, GL_RED, GL_UNSIGNED_BYTE, data);
                unsafe { fixed(void* p = data) { GL.TexImage2D(GL.TEXTURE_2D, 0, (int)GL.LUMINANCE, (uint)w, (uint)h, 0,
					GL.LUMINANCE, GL.UNSIGNED_BYTE, p); } }

			if ((imageFlags & (int)NVGimageFlags.NVG_IMAGE_GENERATE_MIPMAPS) != 0)
			{
				GL.TexParameteri(GL.TEXTURE_2D,
					GL.TEXTURE_MIN_FILTER, (int)GL.LINEAR_MIPMAP_LINEAR);
			}
			else
			{
				GL.TexParameteri(GL.TEXTURE_2D,
					GL.TEXTURE_MIN_FILTER, (int)GL.LINEAR);
			}
			GL.TexParameteri(GL.TEXTURE_2D,
				GL.TEXTURE_MAG_FILTER, (int)GL.LINEAR);

			if ((imageFlags & (int)NVGimageFlags.NVG_IMAGE_REPEATX) != 0)
				GL.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, (int)GL.REPEAT);
			else
				GL.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, (int)GL.CLAMP_TO_EDGE);

			if ((imageFlags & (int)NVGimageFlags.NVG_IMAGE_REPEATY) != 0)
				GL.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, (int)GL.REPEAT);
			else
				GL.TexParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, (int)GL.CLAMP_TO_EDGE);

			GL.PixelStorei(GL.UNPACK_ALIGNMENT, 4);

			glnvg__checkError(gl, "create tex");
			glnvg__bindTexture(gl, 0);

			return tex.id;
		}

		static void glnvg__renderViewport(object uptr, int width, int height, float devicePixelRatio)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			gl.view[0] = (float)width;
			gl.view[1] = (float)height;
		}

		static void glnvg__vset(ref NVGvertex vtx, float x, float y, float u, float v)
		{
			vtx.x = x;
			vtx.y = y;
			vtx.u = u;
			vtx.v = v;
		}

		static int glnvg__maxVertCount(NVGpath[] paths, int npaths)
		{
			int i, count = 0;
			for (i = 0; i < npaths; i++)
			{
				count += paths[i].nfill;
				count += paths[i].nstroke;
			}
			return count;
		}

		static int glnvg__allocPaths(GLNVGcontext gl, int n)
		{
			int ret = 0;
			if (gl.npaths + n > gl.cpaths)
			{
				int cpaths = glnvg__maxi(gl.npaths + n, 128) + gl.cpaths / 2; // 1.5x Overallocate
				//paths = (GLNVGpath*)realloc(gl->paths, sizeof(GLNVGpath) * cpaths);
				Array.Resize<GLNVGpath>(ref gl.paths, cpaths);
				gl.cpaths = cpaths;
			}
			ret = gl.npaths;
			gl.npaths += n;
			return ret;
		}

		static int glnvg__allocVerts(GLNVGcontext gl, int n)
		{
			int ret = 0;
			if (gl.nverts + n > gl.cverts)
			{
				int cverts = glnvg__maxi(gl.nverts + n, 4096) + gl.cverts / 2; // 1.5x Overallocate
				//verts = (NVGvertex*)realloc(gl->verts, sizeof(NVGvertex) * cverts);
				Array.Resize<NVGvertex>(ref gl.verts, cverts);
				gl.cverts = cverts;
			}
			ret = gl.nverts;
			gl.nverts += n;
			return ret;
		}

		static int glnvg__allocFragUniforms(GLNVGcontext gl, int n)
		{
			int ret = 0, structSize = gl.fragSize;
			if (gl.nuniforms + n > gl.cuniforms)
			{
				int cuniforms = glnvg__maxi(gl.nuniforms + n, 128) + gl.cuniforms / 2; // 1.5x Overallocate
				//uniforms = (unsigned char*)realloc(gl->uniforms, structSize * cuniforms);
				Array.Resize<GLNVGfragUniforms>(ref gl.uniforms, cuniforms);
				for (int cont = gl.nuniforms; cont < cuniforms; cont++)
					gl.uniforms[cont] = new GLNVGfragUniforms();
				gl.cuniforms = cuniforms;
			}
			ret = gl.nuniforms * structSize;
			gl.nuniforms += n;
			return ret;
		}

		static NVGcolor glnvg__premulColor(NVGcolor c)
		{
			c.r *= c.a;
			c.g *= c.a;
			c.b *= c.a;
			return c;
		}

		static void glnvg__xformToMat3x4(float[] m3, float[] t)
		{
			m3[0] = t[0];
			m3[1] = t[1];
			m3[2] = 0.0f;
			m3[3] = 0.0f;
			m3[4] = t[2];
			m3[5] = t[3];
			m3[6] = 0.0f;
			m3[7] = 0.0f;
			m3[8] = t[4];
			m3[9] = t[5];
			m3[10] = 1.0f;
			m3[11] = 0.0f;
		}

		static int glnvg__convertPaint(GLNVGcontext gl, ref GLNVGfragUniforms frag, ref NVGpaint paint,
		                               ref NVGscissor scissor, float width, float fringe, float strokeThr)
		{
			GLNVGtexture tex = null;
			float[] invxform = new float[6];

			//memset((byte*)frag, 0, Marshal.SizeOf(*frag));

			frag.innerCol = glnvg__premulColor(paint.innerColor);
			frag.outerCol = glnvg__premulColor(paint.outerColor);

			if (scissor.extent[0] < -0.5f || scissor.extent[1] < -0.5f)
			{
				//memset((byte*)frag->unifGL2.scissorMat, 0, Marshal.SizeOf(frag->unifGL2.scissorMat));
				for (int cont = 0; cont < 12; cont++)
					frag.scissorMat[cont] = 0;
				frag.scissorExt[0] = 1.0f;
				frag.scissorExt[1] = 1.0f;
				frag.scissorScale[0] = 1.0f;
				frag.scissorScale[1] = 1.0f;
			}
			else
			{
				NanoVG.nvgTransformInverse(invxform, scissor.xform);
				glnvg__xformToMat3x4(frag.scissorMat, invxform);
				frag.scissorExt[0] = scissor.extent[0];
				frag.scissorExt[1] = scissor.extent[1];
				frag.scissorScale[0] = (float)Math.Sqrt(scissor.xform[0] * scissor.xform[0] +
					scissor.xform[2] * scissor.xform[2]) / fringe;
				frag.scissorScale[1] = (float)Math.Sqrt(scissor.xform[1] * scissor.xform[1] +
					scissor.xform[3] * scissor.xform[3]) / fringe;
			}

			//memcpy((float*)frag.extent, paint.extent, 2);
			Array.Copy(paint.extent, frag.extent, 2);
			frag.strokeMult = (width * 0.5f + fringe * 0.5f) / fringe;
			frag.strokeThr = strokeThr;

			if (paint.image != 0)
			{
				tex = glnvg__findTexture(gl, paint.image);
				if (tex == null)
					return 0;
				if ((tex.flags & (int)NVGimageFlags.NVG_IMAGE_FLIPY) != 0)
				{
					float[] flipped = new float[6];
					NanoVG.nvgTransformScale(flipped, 1.0f, -1.0f);
					NanoVG.nvgTransformMultiply(flipped, paint.xform);
					NanoVG.nvgTransformInverse(invxform, flipped);
				}
				else
				{
					NanoVG.nvgTransformInverse(invxform, paint.xform);
				}
				frag.type = (int)GLNVGshaderType.NSVG_SHADER_FILLIMG;

				if (tex.type == (int)NVGtexture.NVG_TEXTURE_RGBA)
					frag.texType = (tex.flags & (int)NVGimageFlags.NVG_IMAGE_PREMULTIPLIED) != 0 ? 0 : 1;
				else
					frag.texType = 2;
				//		printf("frag->texType = %d\n", frag->texType);
			}
			else
			{
				frag.type = (int)GLNVGshaderType.NSVG_SHADER_FILLGRAD;
				frag.radius = paint.radius;
				frag.feather = paint.feather;
				NanoVG.nvgTransformInverse(invxform, paint.xform);
			}

			glnvg__xformToMat3x4(frag.paintMat, invxform);

#if ONLY_FOR_DEBUG
			frag->ShowDebug();
#endif

			return 1;
		}

		public static int glnvg__renderUpdateTexture(object uptr, int image, int x, int y, int w, int h, byte[] data)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			GLNVGtexture tex = glnvg__findTexture(gl, image);

			if (tex == null) return 0;
			glnvg__bindTexture(gl, tex.tex);

			GL.PixelStorei(GL.UNPACK_ALIGNMENT, 1);

			int offset = 0;

			// No support for all of skip, need to update a whole row at a time.
			 if (tex.type == (int)NVGtexture.NVG_TEXTURE_RGBA)
			 	offset = y * tex.width * 4;
			 else
			 	offset = y * tex.width;
			
			 x = 0;
			 w = tex.width;

            if (tex.type == (int)NVGtexture.NVG_TEXTURE_RGBA)
                //glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, w, h, GL_RGBA, GL_UNSIGNED_BYTE, data);
                unsafe { fixed(byte* p = data) { GL.TexSubImage2D(GL.TEXTURE_2D, 0, x, y, (uint)w, (uint)h,
					GL.RGBA, GL.UNSIGNED_BYTE, (void*)(p+offset)); }}
			else
				unsafe { fixed(byte* p = data) { GL.TexSubImage2D(GL.TEXTURE_2D, 0, x,y, (uint)w,(uint)h, GL.LUMINANCE, GL.UNSIGNED_BYTE, (void*)(p+offset)); }}

			GL.PixelStorei(GL.UNPACK_ALIGNMENT, 4);

			glnvg__bindTexture(gl, 0);

			return 1;
		}

		public static void glnvg__renderTriangles(object uptr, ref NVGpaint paint, ref NVGscissor scissor,
		                                          NVGvertex[] verts, int nverts)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			GLNVGcall call = glnvg__allocCall(gl);
			GLNVGfragUniforms frag;

			//if (call == NULL) return;

			call.type = (int)GLNVGcallType.GLNVG_TRIANGLES;
			call.image = paint.image;

			// Allocate vertices for all the paths.
			call.triangleOffset = glnvg__allocVerts(gl, nverts);
			if (call.triangleOffset == -1)
				goto error;
			call.triangleCount = nverts;

			//memcpy(&gl->verts[call->triangleOffset], verts, sizeof(NVGvertex) * nverts);
			Array.Copy(verts, 0, gl.verts, call.triangleOffset, nverts);

			// Fill shader
			call.uniformOffset = glnvg__allocFragUniforms(gl, 1);
			if (call.uniformOffset == -1)
				goto error;

			frag = nvg__fragUniformPtr(gl, call.uniformOffset);
			// aquí 'frag' es una copia de 'gl.uniforms[call.uniformOffset]'

			glnvg__convertPaint(gl, ref frag, ref paint, ref scissor, 1.0f, 1.0f, -1.0f);

			frag.type = (int)GLNVGshaderType.NSVG_SHADER_IMG;

			nvg__setFragUniform(gl, call.uniformOffset, ref frag);

			// only for debug
#if ONLY_FOR_DEBUG
			Console.WriteLine("Frag Show");
			frag.ShowDebug();
#endif

			// only for debug
#if ONLY_FOR_DEBUG
			Console.WriteLine("Uniforms[0] Show");
			gl.uniforms[0].ShowDebug();
#endif

			return;

			error:
			// We get here if call alloc was ok, but something else is not.
			// Roll back the last call to prevent drawing it.
			if (gl.ncalls > 0)
				gl.ncalls--;
		}

		public static int glnvg__renderGetTextureSize(object uptr, int image, ref int w, ref int h)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			GLNVGtexture tex = glnvg__findTexture(gl, image);
			if (tex == null)
				return 0;
			w = tex.width;
			h = tex.height;
			return 1;
		}

		public static void glnvg__renderStroke(object uptr, ref NVGpaint paint, ref NVGscissor scissor,
		                                       float fringe, float strokeWidth, NVGpath[] paths, int npaths)
		{
			GLNVGfragUniforms frag;
			GLNVGcontext gl = (GLNVGcontext)uptr;
			GLNVGcall call = glnvg__allocCall(gl);
			int i, maxverts, offset;

			//if (call == NULL) return;

			call.type = (int)GLNVGcallType.GLNVG_STROKE;
			call.pathOffset = glnvg__allocPaths(gl, npaths);
			if (call.pathOffset == -1)
				goto error;
			call.pathCount = npaths;
			call.image = paint.image;

			// Allocate vertices for all the paths.
			maxverts = glnvg__maxVertCount(paths, npaths);
			offset = glnvg__allocVerts(gl, maxverts);
			if (offset == -1)
				goto error;

			for (i = 0; i < npaths; i++)
			{
				GLNVGpath copy = gl.paths[call.pathOffset + i];
				NVGpath path = paths[i];
				//memset(copy, 0, sizeof(GLNVGpath));
				copy.fillCount = 0;
				copy.fillOffset = 0;
				copy.strokeCount = 0;
				copy.strokeOffset = 0;

				if (path.nstroke != 0)
				{
					copy.strokeOffset = offset;
					copy.strokeCount = path.nstroke;
					//memcpy(&gl->verts[offset], path->stroke, sizeof(NVGvertex) * path->nstroke);
					Array.Copy(path.stroke, 0, gl.verts, offset, path.nstroke);
					offset += path.nstroke;
					// TODO ¿Es necesario? ¡¡Sí!! es necesrio
					gl.paths[call.pathOffset + i] = copy;
				}
			}

			if ((gl.flags & (int)NVGcreateFlags.NVG_STENCIL_STROKES) != 0)
			{
				// Fill shader
				call.uniformOffset = glnvg__allocFragUniforms(gl, 2);
				if (call.uniformOffset == -1)
					goto error;

				frag = nvg__fragUniformPtr(gl, call.uniformOffset);
				glnvg__convertPaint(gl, ref frag, ref paint, ref scissor, strokeWidth, fringe, -1.0f);
				// new setfrag
				nvg__setFragUniform(gl, call.uniformOffset, ref frag);

				frag = nvg__fragUniformPtr(gl, call.uniformOffset + gl.fragSize);
				glnvg__convertPaint(gl, ref frag, ref paint, ref scissor, strokeWidth, fringe, 1.0f - 0.5f / 255.0f);
				// new setfrag
				nvg__setFragUniform(gl, call.uniformOffset + gl.fragSize, ref frag);
			}
			else
			{
				// Fill shader
				call.uniformOffset = glnvg__allocFragUniforms(gl, 1);
				if (call.uniformOffset == -1)
					goto error;
				frag = nvg__fragUniformPtr(gl, call.uniformOffset);
				glnvg__convertPaint(gl, ref frag, ref paint, ref scissor, strokeWidth, fringe, -1.0f);
				// new setfrag
				nvg__setFragUniform(gl, call.uniformOffset, ref frag);
			}

			return;

			error:

			// We get here if call alloc was ok, but something else is not.
			// Roll back the last call to prevent drawing it.
			if (gl.ncalls > 0)
				gl.ncalls--;
		}

		static void glnvg__renderFill(object uptr, ref NVGpaint paint, ref NVGscissor scissor, float fringe,
		                              float[] bounds, NVGpath[] paths, int npaths)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			GLNVGcall call = glnvg__allocCall(gl);
			NVGvertex[] quad;
			int iquad = 0;

			GLNVGfragUniforms frag;
			GLNVGfragUniforms frag1;

			int i, maxverts, offset;

			//if (call == NULL) return;

			call.type = (int)GLNVGcallType.GLNVG_FILL;
			call.pathOffset = glnvg__allocPaths(gl, npaths);
			if (call.pathOffset == -1)
				goto error;
			call.pathCount = npaths;
			call.image = paint.image;

			if (npaths == 1 && paths[0].convex != 0)
				call.type = (int)GLNVGcallType.GLNVG_CONVEXFILL;

			// Allocate vertices for all the paths.
			maxverts = glnvg__maxVertCount(paths, npaths) + 6;
			offset = glnvg__allocVerts(gl, maxverts);
			if (offset == -1)
				goto error;

			for (i = 0; i < npaths; i++)
			{
				int icopy = call.pathOffset + i;
				GLNVGpath copy = gl.paths[icopy];
				int ipath = i;
				NVGpath path = paths[ipath];

				//memset(copy, 0, sizeof(GLNVGpath));
				copy.fillCount = 0;
				copy.fillOffset = 0;
				copy.strokeCount = 0;
				copy.strokeOffset = 0;

				if (path.nfill > 0)
				{
					copy.fillOffset = offset;
					copy.fillCount = path.nfill;
					//memcpy(&gl->verts[offset], path->fill, sizeof(NVGvertex) * path->nfill);
					Array.Copy(path.fill, path.ifill, gl.verts, offset, path.nfill);
					offset += path.nfill;
				}
				if (path.nstroke > 0)
				{
					copy.strokeOffset = offset;
					copy.strokeCount = path.nstroke;
					//memcpy(&gl->verts[offset], path->stroke, sizeof(NVGvertex) * path->nstroke);
					Array.Copy(path.stroke, path.istroke, gl.verts, offset, path.nstroke);
					offset += path.nstroke;
				}

				gl.paths[icopy] = copy;
			}

			// Quad
			call.triangleOffset = offset;
			call.triangleCount = 6;
			quad = gl.verts;
			iquad = call.triangleOffset;
			glnvg__vset(ref quad[0 + iquad], bounds[0], bounds[3], 0.5f, 1.0f);
			glnvg__vset(ref quad[1 + iquad], bounds[2], bounds[3], 0.5f, 1.0f);
			glnvg__vset(ref quad[2 + iquad], bounds[2], bounds[1], 0.5f, 1.0f);

			glnvg__vset(ref quad[3 + iquad], bounds[0], bounds[3], 0.5f, 1.0f);
			glnvg__vset(ref quad[4 + iquad], bounds[2], bounds[1], 0.5f, 1.0f);
			glnvg__vset(ref quad[5 + iquad], bounds[0], bounds[1], 0.5f, 1.0f);

			// Setup uniforms for draw calls
			if (call.type == (int)GLNVGcallType.GLNVG_FILL)
			{
				call.uniformOffset = glnvg__allocFragUniforms(gl, 2);
				if (call.uniformOffset == -1)
					goto error;
				// Simple shader for stencil
				frag = nvg__fragUniformPtr(gl, call.uniformOffset);
				//memset(frag, 0, sizeof(*frag));
				frag.strokeThr = -1.0f;
				frag.type = (int)GLNVGshaderType.NSVG_SHADER_SIMPLE;
				// new setfrag
				nvg__setFragUniform(gl, call.uniformOffset, ref frag);
				// Fill shader
				frag1 = nvg__fragUniformPtr(gl, call.uniformOffset + gl.fragSize);
				glnvg__convertPaint(gl, ref frag1, ref paint, ref scissor, fringe, fringe, -1.0f);
				// new setfrag
				nvg__setFragUniform(gl, call.uniformOffset + gl.fragSize, ref frag1);
			}
			else
			{
				call.uniformOffset = glnvg__allocFragUniforms(gl, 1);
				if (call.uniformOffset == -1)
					goto error;
				// Fill shader
				frag = nvg__fragUniformPtr(gl, call.uniformOffset);

#if ONLY_FOR_DEBUG
				frag.ShowDebug();
#endif

				glnvg__convertPaint(gl, ref frag, ref paint, ref scissor, fringe, fringe, -1.0f);
				// new setfrag
				nvg__setFragUniform(gl, call.uniformOffset, ref frag);
			}

			return;

			error:
			// We get here if call alloc was ok, but something else is not.
			// Roll back the last call to prevent drawing it.
			if (gl.ncalls > 0)
				gl.ncalls--;
		}

		static uint glnvg_convertBlendFuncFactor(int factor)
		{
			//NVGblendFactor bf = (NVGblendFactor)factor;

			if (factor == (int)NVGblendFactor.NVG_ONE)
				return GL.ONE;
			if (factor == (int)NVGblendFactor.NVG_SRC_COLOR)
				return GL.SRC_COLOR;
			if (factor == (int)NVGblendFactor.NVG_ONE_MINUS_SRC_COLOR)
				return GL.ONE_MINUS_SRC_COLOR;
			if (factor == (int)NVGblendFactor.NVG_DST_COLOR)
				return GL.DST_COLOR;
			if (factor == (int)NVGblendFactor.NVG_ONE_MINUS_DST_COLOR)
				return GL.ONE_MINUS_DST_COLOR;
			if (factor == (int)NVGblendFactor.NVG_SRC_ALPHA)
				return GL.SRC_ALPHA;
			if (factor == (int)NVGblendFactor.NVG_ONE_MINUS_SRC_ALPHA)
				return GL.ONE_MINUS_SRC_ALPHA;
			if (factor == (int)NVGblendFactor.NVG_DST_ALPHA)
				return GL.DST_ALPHA;
			if (factor == (int)NVGblendFactor.NVG_ONE_MINUS_DST_ALPHA)
				return GL.ONE_MINUS_DST_ALPHA;
			if (factor == (int)NVGblendFactor.NVG_SRC_ALPHA_SATURATE)
				return GL.SRC_ALPHA_SATURATE;
			//if (factor == (int)NVGblendFactor.NVG_ZERO)
			return GL.ZERO;
		}

		static void glnvg__blendCompositeOperation(NVGcompositeOperationState op)
		{
			uint bfs1 = glnvg_convertBlendFuncFactor(op.srcRGB);
			uint bfd1 = glnvg_convertBlendFuncFactor(op.dstRGB);
			uint bfs2 = glnvg_convertBlendFuncFactor(op.srcAlpha);
			uint bfd2 = glnvg_convertBlendFuncFactor(op.dstAlpha);
			/*
			int bs1 = (int)bfs1;
			int bs2 = (int)bfs2;
			int bd1 = (int)bfd1;
			int bd2 = (int)bfd2;
			*/
			GL.BlendFuncSeparate(bfs1, bfd1, bfs2, bfd2);
		}

		static void glnvg__stencilMask(GLNVGcontext gl, uint mask)
		{
			GL.StencilMask(mask);
		}

		static void glnvg__stencilFunc(GLNVGcontext gl, uint func, int ref_, uint mask)
		{
			GL.StencilFunc(func, ref_, mask);
		}

		static GLNVGtexture glnvg__findTexture(GLNVGcontext gl, int id)
		{
			int i;
			for (i = 0; i < gl.ntextures; i++)
				if (gl.textures[i].id == id)
					return gl.textures[i];
			return null;
		}

		#region ¡POINTERS!

		static GLNVGfragUniforms nvg__fragUniformPtr(GLNVGcontext gl, int offset)
		{
			// size of GLNVGfragUniforms = 180 bytes
			offset = (offset / 180);

			return gl.uniforms[offset];
		}

		static void nvg__setFragUniform(GLNVGcontext gl, int offset, ref GLNVGfragUniforms frag)
		{
			// size of GLNVGfragUniforms = 180 bytes
			offset = (offset / 180);

			gl.uniforms[offset] = frag;
		}

		static void glnvg__setUniforms(GLNVGcontext gl, int uniformOffset, int image)
		{
			GLNVGfragUniforms frag = nvg__fragUniformPtr(gl, uniformOffset);

			//CorrigeFrag(ref frag);

			int lt = gl.shader.loc[(int)GLNVGuniformLoc.GLNVG_LOC_FRAG];
			/*
			// only for debug
			Console.WriteLine("************** UniformsArray NO Corregido *************");
			frag.ShowDebug();

			CorrigeSetUniforms(ref frag);

			// only for debug
			Console.WriteLine("************** UniformsArray Corregido ****************");
			frag.ShowDebug();
			*/

			// GL.Uniform4(); NanoVG.NANOVG_GL_UNIFORMARRAY_SIZE = 11; Indica que se pasan 11 vectores de 4 floats

			float[] farr = frag.GetFloats;

			unsafe { fixed(float* p = farr) { GL.Uniform4fv(lt, NanoVG.NANOVG_GL_UNIFORMARRAY_SIZE, p); } }//frag.uniformArray); 

			if (image != 0)
			{
				GLNVGtexture tex = glnvg__findTexture(gl, image);
				glnvg__bindTexture(gl, tex != null ? tex.tex : 0);
				glnvg__checkError(gl, "tex paint tex");
			}
			else
			{
				glnvg__bindTexture(gl, 0);
			}
		}

		#endregion ¡POINTERS!

		static void glnvg__fill(GLNVGcontext gl, ref GLNVGcall call)
		{
			GLNVGpath[] paths = gl.paths;
			int pathOffset = call.pathOffset;
			int i, npaths = call.pathCount;

			// Draw shapes
			GL.Enable(GL.STENCIL_TEST);
			glnvg__stencilMask(gl, 0xff);
			glnvg__stencilFunc(gl, GL.ALWAYS, 0x00, 0xff);
			GL.ColorMask(false, false, false, false);

			// set bindpoint for solid loc
			glnvg__setUniforms(gl, call.uniformOffset, 0);
			glnvg__checkError(gl, "fill simple");

			GL.StencilOpSeparate(GL.FRONT, GL.KEEP, GL.KEEP, GL.INCR_WRAP);
			GL.StencilOpSeparate(GL.BACK, GL.KEEP, GL.KEEP, GL.DECR_WRAP);

			GL.Disable(GL.CULL_FACE);
			for (i = 0; i < npaths; i++)
				GL.DrawArrays(GL.TRIANGLE_FAN, 
					paths[i + pathOffset].fillOffset,
					(uint)paths[i + pathOffset].fillCount);
			GL.Enable(GL.CULL_FACE);

			// Draw anti-aliased pixels
			GL.ColorMask(true, true, true, true);

			glnvg__setUniforms(gl, call.uniformOffset + gl.fragSize, call.image);
			glnvg__checkError(gl, "fill fill");

			if ((gl.flags & (int)NVGcreateFlags.NVG_ANTIALIAS) != 0)
			{
				glnvg__stencilFunc(gl, GL.EQUAL, 0x00, 0xff);
				GL.StencilOp(GL.KEEP, GL.KEEP, GL.KEEP);
				// Draw fringes
				for (i = 0; i < npaths; i++)
					GL.DrawArrays(GL.TRIANGLE_STRIP, 
						paths[i + pathOffset].strokeOffset,
						(uint)paths[i + pathOffset].strokeCount);
			}

			// Draw fill
			glnvg__stencilFunc(gl, GL.NOTEQUAL, 0x0, 0xff);
			GL.StencilOp(GL.ZERO, GL.ZERO, GL.ZERO);
			GL.DrawArrays(GL.TRIANGLES, call.triangleOffset, (uint)call.triangleCount);

			GL.Disable(GL.STENCIL_TEST);
		}

		static void glnvg__convexFill(GLNVGcontext gl, ref GLNVGcall call)
		{
			GLNVGpath[] paths = gl.paths;
			int pathOffset = call.pathOffset;
			int i, npaths = call.pathCount;

			glnvg__setUniforms(gl, call.uniformOffset, call.image);
			glnvg__checkError(gl, "convex fill");

			for (i = 0; i < npaths; i++)
				GL.DrawArrays(GL.TRIANGLE_FAN, 
					paths[i + pathOffset].fillOffset,
					(uint)paths[i + pathOffset].fillCount);
		
			if ((gl.flags & (int)NVGcreateFlags.NVG_ANTIALIAS) != 0)
			{
				// Draw fringes
				for (i = 0; i < npaths; i++)
					GL.DrawArrays(GL.TRIANGLE_STRIP, 
						paths[i + pathOffset].strokeOffset,
						(uint)paths[i + pathOffset].strokeCount);
			}
		}

		static void glnvg__stroke(GLNVGcontext gl, ref GLNVGcall call)
		{
			GLNVGpath[] paths = gl.paths;
			int pathOffset = call.pathOffset;
			int npaths = call.pathCount, i;

			if ((gl.flags & (int)NVGcreateFlags.NVG_STENCIL_STROKES) != 0)
			{

				GL.Enable(GL.STENCIL_TEST);
				glnvg__stencilMask(gl, 0xff);

				// Fill the stroke base without overlap
				glnvg__stencilFunc(gl, GL.EQUAL, 0x0, 0xff);
				GL.StencilOp(GL.KEEP, GL.KEEP, GL.INCR);
				glnvg__setUniforms(gl, call.uniformOffset + gl.fragSize, call.image);
				glnvg__checkError(gl, "stroke fill 0");

				for (i = 0; i < npaths; i++)
					GL.DrawArrays(GL.TRIANGLE_STRIP, 
						paths[i + pathOffset].strokeOffset,
						(uint)paths[i + pathOffset].strokeCount);

				// Draw anti-aliased pixels.
				glnvg__setUniforms(gl, call.uniformOffset, call.image);
				glnvg__stencilFunc(gl, GL.EQUAL, 0x00, 0xff);
				GL.StencilOp(GL.KEEP, GL.KEEP, GL.KEEP);

				for (i = 0; i < npaths; i++)
					GL.DrawArrays(GL.TRIANGLE_STRIP, 
						paths[i + pathOffset].strokeOffset,
						(uint)paths[i + pathOffset].strokeCount);

				// Clear stencil buffer.
				GL.ColorMask(false, false, false, false);
				glnvg__stencilFunc(gl, GL.ALWAYS, 0x0, 0xff);
				GL.StencilOp(GL.ZERO, GL.ZERO, GL.ZERO);
				glnvg__checkError(gl, "stroke fill 1");

				for (i = 0; i < npaths; i++)
					GL.DrawArrays(GL.TRIANGLE_STRIP, 
						paths[i + pathOffset].strokeOffset,
						(uint)paths[i + pathOffset].strokeCount);
			
				GL.ColorMask(true, true, true, true);
				GL.Disable(GL.STENCIL_TEST);

				// glnvg__convertPaint(gl, nvg__fragUniformPtr(gl, call->uniformOffset + gl->fragSize), paint, scissor, strokeWidth, fringe, 1.0f - 0.5f/255.0f);

			}
			else
			{
				glnvg__setUniforms(gl, call.uniformOffset, call.image);
				glnvg__checkError(gl, "stroke fill");

				// Draw Strokes
				for (i = 0; i < npaths; i++)
					GL.DrawArrays(GL.TRIANGLE_STRIP, 
						paths[i + pathOffset].strokeOffset,
						(uint)paths[i + pathOffset].strokeCount);
			}
		}

		static void glnvg__triangles(GLNVGcontext gl, ref GLNVGcall call)
		{
			glnvg__setUniforms(gl, call.uniformOffset, call.image);
			glnvg__checkError(gl, "triangles fill");

			GL.DrawArrays(GL.TRIANGLES, call.triangleOffset, (uint)call.triangleCount);
		}

		static void glnvg__renderFlush(object uptr, NVGcompositeOperationState compositeOperation)
		{
			GLNVGcontext gl = (GLNVGcontext)uptr;
			int i;

			if (gl.ncalls > 0)
			{
				// Setup require GL state.
				GL.UseProgram(gl.shader.prog);

				glnvg__blendCompositeOperation(compositeOperation);
				GL.Enable(GL.CULL_FACE);
				GL.CullFace(GL.BACK);
				GL.FrontFace(GL.CCW);
				GL.Enable(GL.BLEND);
				GL.Disable(GL.DEPTH_TEST);
				GL.Disable(GL.SCISSOR_TEST);
				GL.ColorMask(true, true, true, true);
				GL.StencilMask(0xffffffff);
				GL.StencilOp(GL.KEEP, GL.KEEP, GL.KEEP);
				GL.StencilFunc(GL.ALWAYS, 0, 0xffffffff);
				GL.ActiveTexture(GL.TEXTURE0);
				GL.BindTexture(GL.TEXTURE_2D, 0);

				// Upload vertex data

				GL.BindBuffer(GL.ARRAY_BUFFER, gl.vertBuf);
				//GL.BufferData(GL.ARRAY_BUFFER, gl.nverts * Marshal.SizeOf(typeof(NVGvertex)), gl.verts, GL.STATICDRAW);
				IntPtr iptr = (IntPtr)(gl.nverts * Marshal.SizeOf(typeof(NVGvertex)));
				unsafe { fixed (void* p = gl.verts) { GL.BufferData(GL.ARRAY_BUFFER, (uint)iptr, p, GL.STREAM_DRAW); } }
				GL.EnableVertexAttribArray(0);
				GL.EnableVertexAttribArray(1);

				int s = Marshal.SizeOf(typeof(NVGvertex));
				GL.VertexAttribPointer(0, 2, GL.FLOAT, false, (uint)s, IntPtr.Zero);
				int st = 2 * sizeof(float);
				GL.VertexAttribPointer(1, 2, GL.FLOAT, false, (uint)s, (IntPtr)st);

				// Set view and texture just once per frame.
				int loc1 = gl.shader.loc[(int)GLNVGuniformLoc.GLNVG_LOC_TEX];
				GL.Uniform1i(loc1, 0);
				int loc2 = gl.shader.loc[(int)GLNVGuniformLoc.GLNVG_LOC_VIEWSIZE];
				GL.Uniform2f(loc2, gl.view[0], gl.view[1]);

				for (i = 0; i < gl.ncalls; i++)
				{
					GLNVGcall call = gl.calls[i];
					if (call.type == (int)GLNVGcallType.GLNVG_FILL)
						glnvg__fill(gl, ref call);
					else if (call.type == (int)GLNVGcallType.GLNVG_CONVEXFILL)
						glnvg__convexFill(gl, ref call);
					else if (call.type == (int)GLNVGcallType.GLNVG_STROKE)
						glnvg__stroke(gl, ref call);
					else if (call.type == (int)GLNVGcallType.GLNVG_TRIANGLES)
						glnvg__triangles(gl, ref call);
				}

				GL.DisableVertexAttribArray(0);
				GL.DisableVertexAttribArray(1);

				GL.Disable(GL.CULL_FACE);
				GL.BindBuffer(GL.ARRAY_BUFFER, 0);
				GL.UseProgram(0);
				glnvg__bindTexture(gl, 0);
			}

			// Reset calls
			gl.nverts = 0;
			gl.npaths = 0;
			gl.ncalls = 0;
			gl.nuniforms = 0;
		}

		/// <summary>
		/// nvgCreateGL2 == nvgCreateGL3
		/// </summary>
		/// <param name="ctx">Context.</param>
		/// <param name="flags">Flags.</param>
		public static void nvgCreateGL(ref NVGcontext ctx, int flags)
		{
			NVGparams params_ = new NVGparams();
			ctx = null;
			gl = new GLNVGcontext();

			params_.renderCreate = glnvg__renderCreate;
			params_.renderCreateTexture = glnvg__renderCreateTexture;
			params_.renderCreateTexture2 = glnvg__renderCreateTexture2;
			params_.renderFlush = glnvg__renderFlush;
			params_.renderFill = glnvg__renderFill;
			params_.renderStroke = glnvg__renderStroke;
			params_.renderTriangles = glnvg__renderTriangles;
			params_.renderGetTextureSize = glnvg__renderGetTextureSize;
			params_.renderViewport = glnvg__renderViewport;
			params_.renderUpdateTexture = glnvg__renderUpdateTexture;
			params_.renderDeleteTexture = glnvg__renderDeleteTexture;
			params_.renderCancel = glnvg__renderCancel;
			params_.renderDelete = glnvg__renderDelete;
			params_.userPtr = gl;
			params_.edgeAntiAlias = (flags & (int)NVGcreateFlags.NVG_ANTIALIAS) != 0 ? 1 : 0;

			gl.flags = flags;

			NanoVG.nvgCreateInternal(ref params_, out ctx);
		}
	}

	public class DemoData
	{
		public int fontNormal, fontBold, fontIcons, fontEmoji;
		public int[] images;
		//[12];

		public DemoData()
		{
			images = new int[12];
		}
	}

	public struct GLNVGpath
	{
		public int fillOffset;
		public int fillCount;
		public int strokeOffset;
		public int strokeCount;
	}

	public class GLNVGtexture
	{
		public int id;
		public uint tex;
		public int width, height;
		public int type;
		public int flags;
	}

	public class GLNVGcontext
	{
		public GLNVGshader shader;
		public GLNVGtexture[] textures;
		// [2]
		public float[] view;
		public int ntextures;
		public int ctextures;
		public int textureId;
		public uint vertBuf;
		public int fragSize;
		public int flags;

		// Per frame buffers
		public GLNVGcall[] calls;
		public int ccalls;
		public int ncalls;
		public GLNVGpath[] paths;
		public int cpaths;
		public int npaths;
		public NVGvertex[] verts;
		public int cverts;
		public int nverts;
		public GLNVGfragUniforms[] uniforms;
		public int cuniforms;
		public int nuniforms;

		// cached state

		public GLNVGcontext()
		{
			view = new float[2];
		}
	}

	public class GLNVGshader
	{
		public uint prog;
		public uint frag;
		public uint vert;
		//[GLNVG_MAX_LOCS];
		public int[] loc;

		public GLNVGshader()
		{
			loc = new int[(int)GLNVGuniformLoc.GLNVG_MAX_LOCS];
		}
	}

	public class GLNVGcall
	{
		public int type;
		public int image;
		public int pathOffset;
		public int pathCount;
		public int triangleOffset;
		public int triangleCount;
		public int uniformOffset;
	}

	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public class GLNVGfragUniforms
	{
		// matrices are actually 3 vec4s

		// float[12]
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)]
		public float[] scissorMat;
		// float[12]
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)]
		public float[] paintMat;
		//[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public NVGcolor innerCol;
		//[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		public NVGcolor outerCol;
		// float[2]
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public float[] scissorExt;
		// float[2]
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public float[] scissorScale;
		// float[2]
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public float[] extent;

		public float radius;
		public float feather;
		public float strokeMult;
		public float strokeThr;

		float texType_;

		public int texType
		{
			get { return (int)texType_; }
			set { texType_ = value; }
		}

		float type_;

		public int type
		{
			get { return (int)type_; }
			set { type_ = value; }
		}

		public GLNVGfragUniforms()
		{
			scissorMat = new float[12];
			paintMat = new float[12];
			innerCol = new NVGcolor();
			outerCol = new NVGcolor();
			scissorExt = new float[2];
			scissorScale = new float[2];
			extent = new float[2];
		}

		public float[] GetFloats
		{
			get
			{
				int size = (int)GLNVGfragUniforms.GetSize;
				int felements = (int)Math.Ceiling((float)(size / sizeof(float)));
				float[] farr = new float[felements];

				IntPtr ptr = Marshal.AllocHGlobal(size);
				Marshal.StructureToPtr(this, ptr, true);
				Marshal.Copy(ptr, farr, 0, felements);
				Marshal.FreeHGlobal(ptr);
				return farr;
			}
		}

		/// <summary>
		/// Gets the size of the <see cref="GLNVGfragUniforms"/> in bytes.
		/// </summary>
		/// <value>The size of the GLNVGfragUniforms struct.</value>
		public static uint GetSize
		{
			get
			{
				// 176 bytes
				//return (uint)(12 + 12 + 4 + 4 + 2 + 2 + 2 + 6) * 4;
				return (uint)Marshal.SizeOf(typeof(GLNVGfragUniforms));
			}
		}
	}

}

